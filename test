import re
from const import *

variables = {}
constants = set()

OPSEQ = [
    (EQUALS.split(), '=='),
    (GTE.split(), '>='),
    (LTE.split(), '<='),
    (GREATER.split(), '>'),
    (LESS.split(), '<'),
    (NOT.split(), '!=')
]

def tokenize(code):
    tokens = []
    patternmap = {
        'STRING': r'"([^"]*)"',
        'FLOAT': r'\d+\.\d+',
        'INTEGER': r'\d+',
        'OPERATOR': '|'.join(map(re.escape, [EQUALS, GTE, LTE, GREATER, LESS, NOT])),
        'SYMBOL': r'[()\[\]{};,]',
        'KEYWORD': '|'.join(map(re.escape, [ELIF, IF_OPEN, THEN, ELSE, IF_CLOSE, DO, BREAK, CONTINUE, PASS, GOTO, LABEL, WHILE_OPEN, WHILE_CLOSE, FOR_OPEN, FOR_CLOSE, IN, OUTPUT, OUTPUT_NEWLINE, INPUT, INPUT_TO])),
        'TYPE': '|'.join(map(re.escape, ALL_TYPES)),
        'ID': r'[a-zA-Z_][a-zA-Z0-9_]*',
        'SKIP': r'[ \t\n]+',
        'MISMATCH': r'.',
    }

    toxreg = '|'.join(f'(?P<{key}>{val})' for key, val in patternmap.items())
    for match in re.finditer(toxreg, code):
        kind = match.lastgroup
        value = match.group()

        if kind == 'STRING':
            tokens.append(('STRING', value[1:-1]))
        elif kind == 'FLOAT':
            tokens.append(('FLOAT', float(value)))
        elif kind == 'INTEGER':
            tokens.append(('INTEGER', int(value)))
        elif kind in ['KEYWORD', 'TYPE']:
            tokens.append((value.upper(), value))
        elif kind == 'OPERATOR':
            tokens.append((value, value))
        elif kind == 'SYMBOL':
            tokens.append((value, value))
        elif kind == 'ID':
            tokens.append(('ID', value))
        elif kind == 'SKIP':
            continue
        else:
            raise SyntaxError(f"Unexpected character: {value}")

    # Handle multi-word operators
    i = 0
    while i < len(tokens):
        for seqwords, op in OPSEQ:
            if tokens[i:i+len(seqwords)] == [('ID', word) for word in seqwords]:
                tokens[i:i+len(seqwords)] = [('OPERATOR', op)]
                break
        i += 1

    return tokens


class ParseError(Exception):
    pass


class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0

    def curr(self):
        return self.tokens[self.pos] if self.pos < len(self.tokens) else None

    def consume(self, expected=None):
        token = self.curr()
        if not token:
            raise ParseError("Unexpected end of input")
        if expected and token[0] != expected:
            raise ParseError(f"Expected {expected} but got {token[0]} instead")
        self.pos += 1
        return token

    def parse(self):
        ast = []
        while self.curr():
            ast.append(self.parseline())
        return ast

    def parseline(self):
        token = self.curr()
        if token[0] == NEW_VAR_IDENT.upper():
            return self.declaration()
        elif token[0] == IF_OPEN.upper():
            return self.ifelse()
        elif token[0] == WHILE_OPEN.upper():
            return self.whileloop()
        elif token[0] == OUTPUT.upper():
            return self.output()
        elif token[0] == INPUT.upper():
            return self.input()
        elif token[0] == 'ID':
            return self.assignment()
        else:
            raise ParseError(f"Unexpected token: {token[0]}")

    def declaration(self):
        self.consume(NEW_VAR_IDENT.upper())
        isconst = False
        vartype = self.consume("ID")[1]
        varname = self.consume("ID")[1]

        value = None
        if self.curr() and self.curr()[1] == ASSIGNMENT_OPERATOR:
            self.consume()
            value = self.expr()

        return ("DECLARE", varname, vartype, value, isconst)

    def ifelse(self):
        self.consume(IF_OPEN.upper())
        condition = self.expr()
        self.consume(THEN.upper())
        self.consume(DO.upper())
        body = []

        while self.curr() and self.curr()[0] not in (ELIF.upper(), ELSE.upper(), IF_CLOSE.upper()):
            body.append(self.parseline())

        self.consume(IF_CLOSE.upper())
        return ("IF", condition, body)

    def whileloop(self):
        self.consume(WHILE_OPEN.upper())
        condition = self.expr()
        self.consume(DO.upper())
        body = []

        while self.curr() and self.curr()[0] != WHILE_CLOSE.upper():
            body.append(self.parseline())

        self.consume(WHILE_CLOSE.upper())
        return ("WHILE", condition, body)

    def output(self):
        self.consume(OUTPUT.upper())
        value = self.expr()
        return ("PRINT", value)

    def input(self):
        self.consume(INPUT.upper())
        varname = self.consume("ID")[1]
        return ("RECEIVE", varname)

    def assignment(self):
        varname = self.consume("ID")[1]
        self.consume(REASSIGNMENT_OPERATOR.upper())
        value = self.expr()
        return ("ASSIGN", varname, value)

    def expr(self):
        token = self.consume()
        if token[0] == "INTEGER":
            return ("INTEGER", token[1])
        elif token[0] == "FLOAT":
            return ("FLOAT", token[1])
        elif token[0] == "STRING":
            return ("STRING", token[1])
        elif token[0] == "ID":
            return ("VARIABLE", token[1])
        else:
            raise ParseError(f"Invalid expression {token}")


class Evaluator:
    def evaluate(self, ast):
        for node in ast:
            self.evalnode(node)

    def evalnode(self, node):
        if node[0] == "DECLARE":
            self.decl(node)
        elif node[0] == "PRINT":
            self.output(node)
        else:
            raise RuntimeError(f"Unknown node type: {node[0]}")

    def decl(self, node):
        _, varname, vartype, value, _ = node
        if varname in constants:
            raise RuntimeError(f"Constant {varname} cannot be changed")
        variables[varname] = value

    def output(self, node):
        _, value = node
        print(value[1])


# Test Sample Script
sigma_code = '''
new variable int count is 3
print count
'''

tokens = tokenize(sigma_code)
parser = Parser(tokens)
ast = parser.parse()

evaluator = Evaluator()
evaluator.evaluate(ast)
